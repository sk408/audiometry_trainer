import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import {
  Box,
  Button,
  Paper,
  Typography,
  Divider,
  Stack,
  IconButton,
  Tooltip,
  Chip,
  LinearProgress,
  Alert,
  Fade,
  Avatar,
  Switch,
  FormControlLabel,
  Grid,
  Snackbar
} from '@mui/material';
import {
  VolumeUp,
  SkipNext,
  Check,
  Clear,
  HelpOutline,
  KeyboardTab,
  Hearing,
  School,
  ArrowUpward,
  ArrowDownward
} from '@mui/icons-material';
import { TestSession, TestStep, HearingProfile, ThresholdPoint, HearingLevel, Frequency } from '../interfaces/AudioTypes';
import testingService from '../services/TestingService';
import audioService from '../services/AudioService';
import Audiogram from './Audiogram';
import PatientImage from './PatientImage';
import GuidancePanel from './GuidancePanel';

interface TestingInterfaceProps {
  patient: HearingProfile;
  onComplete: (session: TestSession) => void;
  onCancel: () => void;
}

const TestingInterface: React.FC<TestingInterfaceProps> = ({
  patient,
  onComplete,
  onCancel
}) => {
  const [session, setSession] = useState<TestSession | null>(null);
  const [currentStep, setCurrentStep] = useState<TestStep | null>(null);
  const [testProgress, setTestProgress] = useState(0);
  const [showHelp, setShowHelp] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  const [patientResponse, setPatientResponse] = useState<boolean | null>(null);
  const [showResponseIndicator, setShowResponseIndicator] = useState(false);
  const [toneActive, setToneActive] = useState(false);
  const toneIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const [trainerMode, setTrainerMode] = useState(false);
  const [currentGuidance, setCurrentGuidance] = useState<string>('Start testing at a comfortable level (30-40 dB).');
  const [procedurePhase, setProcedurePhase] = useState<'initial' | 'descending' | 'ascending' | 'threshold' | 'complete'>('initial');
  const [responseCount, setResponseCount] = useState(0);
  const [lastResponseLevel, setLastResponseLevel] = useState<number | null>(null);
  const [suggestedAction, setSuggestedAction] = useState<'present' | 'increase' | 'decrease' | 'store_threshold' | 'next'>('present');
  const [patientJustResponded, setPatientJustResponded] = useState(false);
  // Track when threshold phase started to ignore previous responses
  const [thresholdPhaseStartTime, setThresholdPhaseStartTime] = useState<number | null>(null);
  // Use a ref to track the last presentation time to prevent multiple responses
  const lastPresentationTimeRef = useRef<number>(0);
  // Add a new ref to track the last PROCESSED presentation time
  const lastProcessedPresentationRef = useRef<number>(0);
  // Update response counts to be frequency and ear specific
  const [responseCounts, setResponseCounts] = useState<{
    [frequency: number]: {
      [ear: string]: {
        [level: number]: {total: number, heard: number}
      }
    }
  }>({});

  // Simulate virtual patient response based on hearing threshold
  const simulatePatientResponse = useCallback(() => {
    if (!currentStep || !patient) return false;
    
    // Find matching threshold for current frequency and ear
    const matchingThreshold = patient.thresholds.find(
      t => t.frequency === currentStep.frequency && 
           t.ear === currentStep.ear && 
           t.testType === currentStep.testType
    );
    
    if (!matchingThreshold) return false;
    
    // Patient responds if the current level is at or above their threshold
    // Add some variability (Â±5 dB) to make it more realistic
    const variability = Math.floor(Math.random() * 10) - 5;
    const effectiveThreshold = matchingThreshold.hearingLevel + variability;
    
    return currentStep.currentLevel >= effectiveThreshold;
  }, [currentStep, patient]);

  // Update trainer mode state based on patient response
  const updateTrainerState = useCallback((didRespond: boolean) => {
    // We'll process responses even if not in trainer mode
    // But we'll only update UI state if trainer mode is on
    if (!currentStep) {
      console.log('Cannot update trainer state: currentStep is falsy');
      return;
    }
    
    console.log('ðŸ” Processing response:', didRespond, 'in phase:', procedurePhase, 'trainer mode:', trainerMode);
    
    // Always record the response for guidance purposes
    if (didRespond) {
      console.log('Patient responded - updating state');
      
      // Only update UI state if trainer mode is on
      if (trainerMode) {
        if (procedurePhase === 'initial') {
          // If patient responds on first presentation, change to descending phase
          setProcedurePhase('descending');
          setSuggestedAction('decrease');
          setCurrentGuidance('The patient responded at this level. According to Hughson-Westlake, the next step would be to decrease by 10 dB and present the tone again.');
          console.log('Initial phase - patient responded, changing to descending phase');
        } else if (procedurePhase === 'descending') {
          // Continue descending
          setProcedurePhase('descending');
          setSuggestedAction('decrease');
          setCurrentGuidance('The patient can still hear at this level. In the descending phase, you should continue to decrease by 10 dB intervals.');
          console.log('Descending phase - patient responded, suggesting continue decreasing');
        } else if (procedurePhase === 'ascending') {
          // If patient responds during ascending phase, we've found a potential threshold
          setProcedurePhase('threshold');
          
          // Track responses at the current level
          const newLevel = currentStep.currentLevel;
          
          // Update response counts for this level
          const levelResponseCounts = { ...responseCounts };
          if (!levelResponseCounts[currentStep.frequency]) {
            levelResponseCounts[currentStep.frequency] = {};
          }
          if (!levelResponseCounts[currentStep.frequency][currentStep.ear]) {
            levelResponseCounts[currentStep.frequency][currentStep.ear] = {};
          }
          if (!levelResponseCounts[currentStep.frequency][currentStep.ear][newLevel]) {
            levelResponseCounts[currentStep.frequency][currentStep.ear][newLevel] = { total: 0, heard: 0 };
          }
          levelResponseCounts[currentStep.frequency][currentStep.ear][newLevel].total += 1;
          levelResponseCounts[currentStep.frequency][currentStep.ear][newLevel].heard += 1;
          setResponseCounts(levelResponseCounts);
          
          // Set UI to show the current level we're tracking
          setLastResponseLevel(newLevel);
          
          // Calculate how many responses we have at this level
          const heardCount = levelResponseCounts[currentStep.frequency][currentStep.ear][newLevel].heard;
          const totalCount = levelResponseCounts[currentStep.frequency][currentStep.ear][newLevel].total;
          
          setSuggestedAction('decrease');
          setCurrentGuidance(`You've found a potential threshold! The patient is now responding at ${newLevel} dB (${heardCount}/${totalCount}). According to Hughson-Westlake, decrease by 10 dB and present the tone again to continue testing.`);
          console.log(`Ascending phase - patient responded, changed to threshold phase, response count at ${newLevel}dB is ${heardCount}/${totalCount}`);
          
          // Important: Record the timestamp when entering threshold phase to ignore previous responses
          setThresholdPhaseStartTime(Date.now());
          console.log(`â° Setting threshold phase start time to ${Date.now()}`);
        } else if (procedurePhase === 'threshold') {
          // Continue tracking responses at the current level
          const currentLevel = currentStep.currentLevel;
          
          // Update response counts for this level
          const levelResponseCounts = { ...responseCounts };
          if (!levelResponseCounts[currentStep.frequency]) {
            levelResponseCounts[currentStep.frequency] = {};
          }
          if (!levelResponseCounts[currentStep.frequency][currentStep.ear]) {
            levelResponseCounts[currentStep.frequency][currentStep.ear] = {};
          }
          if (!levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel]) {
            levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel] = { total: 0, heard: 0 };
          }
          levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel].total += 1;
          levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel].heard += 1;
          setResponseCounts(levelResponseCounts);
          
          // Set UI to show the current level we're tracking
          setLastResponseLevel(currentLevel);
          
          // Calculate how many responses we have at this level
          const heardCount = levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel].heard;
          const totalCount = levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel].total;
          
          // Make sure this is a new student-initiated presentation
          if (thresholdPhaseStartTime && lastPresentationTimeRef.current > thresholdPhaseStartTime) {
            console.log(`ðŸ”¢ Current responses at ${currentLevel}dB: ${heardCount}/${totalCount}`);
            console.log(`â° Presentation time: ${lastPresentationTimeRef.current}, Threshold phase start: ${thresholdPhaseStartTime}`);
            
            // CRITICAL FIX: Check if this is a new presentation we haven't processed yet
            if (lastPresentationTimeRef.current > lastProcessedPresentationRef.current) {
              // Update the last processed time to prevent double counting
              console.log(`âœ… New presentation detected. Last processed: ${lastProcessedPresentationRef.current}, Current: ${lastPresentationTimeRef.current}`);
              lastProcessedPresentationRef.current = lastPresentationTimeRef.current;
              
              // FIXED HUGHSON-WESTLAKE PROTOCOL:
              // 1. We need to have at least 3 presentations at this level 
              // 2. Patient must respond to at least 2 of them to confirm threshold
              // 3. If we already have 2 responses at this level, it's confirmed as threshold
              if (totalCount >= 3) {
                if (heardCount >= 2) {
                  // Confirmed threshold: at least 2 out of 3 responses at this level
                  console.log(`âœ… Threshold CONFIRMED at ${currentLevel}dB with ${heardCount}/${totalCount} responses.`);
                  setProcedurePhase('complete');
                  setSuggestedAction('store_threshold');
                  setCurrentGuidance(`Excellent! You have established a threshold at ${currentLevel} dB. The patient has responded ${heardCount} times out of ${totalCount} at this level, which meets the criteria of "2 out of 3" responses needed to establish a threshold. You can now store this value and move to the next frequency.`);
                } else {
                  // Failed threshold confirmation: less than 2 out of 3 responses
                  console.log(`âŒ Threshold NOT confirmed at ${currentLevel}dB with only ${heardCount}/${totalCount} responses.`);
                  setSuggestedAction('increase');
                  setCurrentGuidance(`The patient responded only ${heardCount} times out of ${totalCount} at ${currentLevel} dB, which doesn't meet the criteria of "2 out of 3" responses needed to establish a threshold. According to Hughson-Westlake, you should increase by 5 dB and continue testing.`);
                }
              } else if (heardCount >= 2) {
                // Already have 2 positive responses, but continue for confirmation
                console.log(`ðŸ‘ Already have ${heardCount} positive responses at ${currentLevel}dB, need one more presentation for confirmation.`);
                setSuggestedAction('present');
                setCurrentGuidance(`Good! The patient has responded ${heardCount} times at ${currentLevel} dB. Present the tone one more time at this level to confirm the threshold (need at least 2 out of 3).`);
              } else if (totalCount === 2 && heardCount === 1) {
                // Have 1 out of 2 responses, need one more presentation
                console.log(`â³ Have 1 out of 2 responses at ${currentLevel}dB, need one more presentation for confirmation.`);
                setSuggestedAction('present');
                setCurrentGuidance(`The patient has responded once out of ${totalCount} presentations at ${currentLevel} dB. Present the tone one more time at this level to see if you can confirm the threshold (need at least 2 out of 3).`);
              } else {
                // Continue testing at this level
                console.log(`â³ Need more responses at ${currentLevel}dB (have ${heardCount}/${totalCount}, need at least 2/3)`);
                setSuggestedAction('present');
                setCurrentGuidance(`The patient has responded ${heardCount} time(s) out of ${totalCount} at ${currentLevel} dB. Continue presenting at this level to determine if it's the threshold.`);
              }
            } else {
              console.log(`âš ï¸ Double counting prevented! This presentation (${lastPresentationTimeRef.current}) was already processed.`);
            }
          } else {
            console.log('âš ï¸ Ignoring response from before threshold phase started in updateTrainerState');
            console.log(`â° Presentation time: ${lastPresentationTimeRef.current}, Threshold phase start: ${thresholdPhaseStartTime}`);
          }
        }
      }
    } else {
      // No response
      console.log('Patient did NOT respond - updating state');
      
      // Only update UI state if trainer mode is on
      if (trainerMode) {
        if (procedurePhase === 'initial') {
          // Initial level too low, suggest increasing
          setSuggestedAction('increase');
          setCurrentGuidance('The patient did not respond to the initial presentation. This suggests the starting level was too low. Increase the level by 10-15 dB and try again.');
          console.log('Initial phase - no response, suggest increasing');
        } else if (procedurePhase === 'descending') {
          // Move to ascending phase when patient stops responding during descending
          setProcedurePhase('ascending');
          setSuggestedAction('increase');
          setCurrentGuidance('The patient no longer responds at this level. This means we\'ve gone below their threshold. Now switch to the ascending phase: increase by 5 dB steps until the patient responds again. Note that we use smaller steps (5 dB) when ascending to more precisely determine the threshold.');
          console.log('Descending phase - no response, changing to ascending phase');
        } else if (procedurePhase === 'threshold') {
          // During threshold determination - if no response, track it and suggest increasing by 5dB
          const currentLevel = currentStep.currentLevel;
          
          // Update response counts for this level
          const levelResponseCounts = { ...responseCounts };
          if (!levelResponseCounts[currentStep.frequency]) {
            levelResponseCounts[currentStep.frequency] = {};
          }
          if (!levelResponseCounts[currentStep.frequency][currentStep.ear]) {
            levelResponseCounts[currentStep.frequency][currentStep.ear] = {};
          }
          if (!levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel]) {
            levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel] = { total: 0, heard: 0 };
          }
          levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel].total += 1;
          // No increment for heard count since patient didn't respond
          setResponseCounts(levelResponseCounts);
          
          // Get the counts for this level
          const heardCount = levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel].heard;
          const totalCount = levelResponseCounts[currentStep.frequency][currentStep.ear][currentLevel].total;
          
          console.log(`ðŸ”¢ Current responses at ${currentLevel}dB: ${heardCount}/${totalCount}`);
          
          // Update last processed time to prevent double counting
          if (lastPresentationTimeRef.current > lastProcessedPresentationRef.current) {
            lastProcessedPresentationRef.current = lastPresentationTimeRef.current;
          }
          
          // FIXED HUGHSON-WESTLAKE PROTOCOL FOR NO RESPONSE:
          // If we have at least 3 presentations and less than 2 positive responses, 
          // this level is below threshold.
          if (totalCount >= 3 && heardCount < 2) {
            // Failed to confirm threshold at this level - move up 5 dB
            console.log(`âŒ Level ${currentLevel}dB is below threshold with only ${heardCount}/${totalCount} positive responses.`);
            setSuggestedAction('increase');
            setCurrentGuidance(`The patient responded only ${heardCount} times out of ${totalCount} at ${currentLevel} dB, which confirms this level is below threshold. According to Hughson-Westlake, you should increase by 5 dB and continue testing.`);
          } else if (totalCount - heardCount >= 2) {
            // Already have 2 negative responses, suggest increasing
            console.log(`ðŸ‘Ž Already have ${totalCount - heardCount} negative responses at ${currentLevel}dB, suggesting to increase.`);
            setSuggestedAction('increase');
            setCurrentGuidance(`The patient has failed to respond ${totalCount - heardCount} times out of ${totalCount} at ${currentLevel} dB. According to Hughson-Westlake, you should increase by 5 dB and continue testing.`);
          } else {
            // Continue testing at this level
            setSuggestedAction('present');
            setCurrentGuidance(`Patient did not respond at ${currentLevel} dB (${heardCount}/${totalCount} responses so far). Continue testing at this level to determine if it's the threshold.`);
          }
        } else if (procedurePhase === 'ascending') {
          // Continue ascending
          setProcedurePhase('ascending');
          setSuggestedAction('increase');
          setCurrentGuidance('Patient still doesn\'t respond at this level. Continue to increase by 5 dB steps until you get a response. Remember, we use smaller 5 dB steps during the ascending phase for more precise threshold determination.');
          console.log('Ascending phase - no response, continue ascending');
        }
      }
    }
  }, [trainerMode, currentStep, procedurePhase, responseCounts, thresholdPhaseStartTime]);

  // Process automatic patient response during tone presentation
  const processAutomaticResponse = useCallback(() => {
    // This function handles automatic responses during tone presentation (non-threshold phases)
    if (!currentStep) {
      console.log('âŒ Cannot process response: currentStep is null');
      return;
    }
    
    console.log('ðŸ” Processing automatic response with toneActive =', toneActive);
    
    // Simulate patient response
    const didRespond = simulatePatientResponse();
    console.log('ðŸ‘‚ Patient response simulation result:', didRespond);
    
    // Update UI to show response
    setPatientResponse(didRespond);
    setShowResponseIndicator(true);
    
    // Display user-friendly notification about patient response
    if (didRespond) {
      console.log('ðŸ‘‚ Patient is responding to the tone!');
      // Set the flag that patient just responded (for the guidance panel)
      setPatientJustResponded(true);
      
      // Reset the flag after a delay, but leave patientResponse true
      setTimeout(() => {
        setPatientJustResponded(false);
      }, 3000);
    } else {
      console.log('ðŸ‘‚ Patient does not hear this tone.');
      setPatientJustResponded(false);
    }
    
    // Record the response time
    const responseTimestamp = Date.now();
    console.log('â±ï¸ Response time:', responseTimestamp);
    
    // Record the response in the testing service WITHOUT automatic level adjustment
    // during tone presentation to prevent unwanted level changes
    console.log('ðŸ’¾ Recording response WITHOUT level adjustment. Current phase:', procedurePhase);
    testingService.recordResponseWithoutAdjustment(didRespond);
    
    // Store the current user-set level before getting the updated step
    const currentUserLevel = currentStep.currentLevel;
    
    // Update current step after recording response
    const newStep = testingService.getCurrentStep();
    
    // IMPORTANT: Preserve the user's manually set level rather than using whatever comes back from the service
    if (newStep && currentUserLevel !== newStep.currentLevel) {
      console.log(`ðŸ”„ Preserving user-set level: ${currentUserLevel}dB instead of service level: ${newStep.currentLevel}dB`);
      newStep.currentLevel = currentUserLevel;
    }
    
    setCurrentStep(newStep);
    
    // Check if test is complete
    const updatedSession = testingService.getCurrentSession();
    if (updatedSession) {
      // Also ensure the session has the correct level
      if (updatedSession.testSequence && updatedSession.testSequence[updatedSession.currentStep]) {
        updatedSession.testSequence[updatedSession.currentStep].currentLevel = currentUserLevel;
      }
      
      setSession(updatedSession);
      
      if (updatedSession.completed) {
        onComplete(updatedSession);
      }
    }
    
    // EXTREMELY IMPORTANT: NEVER update the trainer state during tone presentation
    // The trainer state will ONLY be updated when the tone stops in the stopTone function
    console.log('âš ï¸ STRICTLY NOT updating trainer state during tone presentation. Phase remains:', procedurePhase);
    
  }, [currentStep, simulatePatientResponse, onComplete, procedurePhase, setPatientResponse, setShowResponseIndicator, setPatientJustResponded, setCurrentStep, setSession]);

  // Process response without changing levels - just UI indication
  const processSimpleResponse = useCallback(() => {
    if (!currentStep) {
      console.log('Cannot process response: currentStep is null');
      return;
    }
    
    // Simulate patient response
    const didRespond = simulatePatientResponse();
    console.log('Patient response simulation result (simple):', didRespond);
    
    // Update UI to show response
    setPatientResponse(didRespond);
    setShowResponseIndicator(true);
    
    // Display user-friendly notification about patient response
    if (didRespond) {
      console.log('Patient is responding to the tone!');
      // Set the flag that patient just responded (for the guidance panel)
      setPatientJustResponded(true);
      
      // Reset the flag after a delay, but leave patientResponse true
      setTimeout(() => {
        setPatientJustResponded(false);
      }, 3000);
    } else {
      console.log('Patient does not hear this tone.');
      setPatientJustResponded(false);
    }
    
    // Record the response in the testing service WITHOUT automatic level adjustment
    testingService.recordResponse(didRespond);
    
    // DON'T update steps or session here to prevent auto level changes
  }, [currentStep]);

  // Stop playing tone
  const stopTone = useCallback(() => {
    if (toneIntervalRef.current) {
      clearInterval(toneIntervalRef.current);
      toneIntervalRef.current = null;
    }
    
    audioService.stopTone();
    
    // Get current states BEFORE changing any state to avoid race conditions
    const currentToneActive = toneActive;
    const currentPatientResponse = patientResponse;
    const currentProcedurePhase = procedurePhase;
    const currentThresholdPhaseStartTime = thresholdPhaseStartTime;
    
    // Log current state for debugging
    console.log('ðŸ›‘ Stopping tone with current state:', {
      toneActive: currentToneActive,
      patientResponse: currentPatientResponse,
      phase: currentProcedurePhase
    });
    
    // Set tone inactive
    setToneActive(false);
    
    // IMMEDIATELY reset patient response visuals when stopping tone
    setPatientResponse(null);
    setShowResponseIndicator(false);
    setPatientJustResponded(false);
    
    // Record the time of this presentation to prevent duplicate responses
    const presentationStopTime = Date.now();
    lastPresentationTimeRef.current = presentationStopTime;
    
    console.log('â±ï¸ Presentation stopped at:', presentationStopTime);
    
    // IMPORTANT: Simulate a patient response for internal processing, but don't show visual feedback
    let effectiveResponse = currentPatientResponse;
    if (effectiveResponse === null) {
      // If we haven't determined a response yet, do so now
      const didRespond = simulatePatientResponse();
      console.log('ðŸ”Š Simulating patient response at tone stop for internal processing only:', didRespond);
      
      // Use this response for processing but don't update UI
      effectiveResponse = didRespond;
    }
    
    // Always process a response after stopping the tone, regardless of phase
    if (currentStep) {
      console.log('ðŸ’» Processing tone stop in phase:', currentProcedurePhase);
      
      if (currentProcedurePhase === 'threshold') {
        console.log('ðŸŽ¯ Processing threshold response with student input');
        
        // Make sure this is a fresh student-initiated presentation
        if (currentThresholdPhaseStartTime && presentationStopTime > currentThresholdPhaseStartTime) {
          console.log(`âœ… Valid student-initiated presentation: threshold started at ${currentThresholdPhaseStartTime}, presentation at ${presentationStopTime}`);
          
          // CRITICAL FIX: Only process if this presentation hasn't been processed
          if (presentationStopTime > lastProcessedPresentationRef.current) {
            console.log(`âœ… Processing new presentation. Current: ${presentationStopTime}, Last processed: ${lastProcessedPresentationRef.current}`);
            
            // Process the student-initiated response
            if (effectiveResponse !== null) {
              // Store the response in the testing service
              testingService.recordResponseWithoutAdjustment(Boolean(effectiveResponse));
              
              // IMPORTANT: Update trainer state IMMEDIATELY, not in a timeout
              // This ensures the guidance updates immediately after tone stops
              console.log('ðŸ”„ Immediately updating trainer state with response:', effectiveResponse);
              updateTrainerState(Boolean(effectiveResponse));
            }
          } else {
            console.log(`âš ï¸ Presentation already processed in stopTone! Current: ${presentationStopTime}, Last processed: ${lastProcessedPresentationRef.current}`);
          }
        } else {
          console.log('âš ï¸ Ignoring response from before threshold phase started');
        }
      } else {
        // For other phases, process response normally
        console.log('ðŸ“Š Processing final response for non-threshold phase:', effectiveResponse);
        
        // Store the response in the testing service
        testingService.recordResponseWithoutAdjustment(Boolean(effectiveResponse));
        
        // IMPORTANT: Update trainer state IMMEDIATELY, not in a timeout
        // This ensures the guidance updates immediately after tone stops
        console.log('ðŸ”„ Immediately updating trainer state with response:', effectiveResponse);
        updateTrainerState(Boolean(effectiveResponse));
      }
    }
  }, [patientResponse, currentStep, updateTrainerState, procedurePhase, thresholdPhaseStartTime]);

  // Clean up interval on unmount
  useEffect(() => {
    return () => {
      if (toneIntervalRef.current) {
        clearInterval(toneIntervalRef.current);
      }
      audioService.stopTone();
    };
  }, []);

  // Handle mouse up event outside the component
  useEffect(() => {
    const handleMouseUp = () => {
      if (toneActive) {
        stopTone();
      }
    };

    document.addEventListener('mouseup', handleMouseUp);
    return () => {
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [toneActive, stopTone]);

  // Handle level adjustment - update for trainer mode
  const handleAdjustLevel = useCallback((change: number) => {
    if (!currentStep) return;
    
    try {
      // Create a proper new object without mutating the original
      const newLevel = Math.max(-10, Math.min(120, currentStep.currentLevel + change)) as HearingLevel;
      
      // Update trainer mode state based on level change
      if (trainerMode) {
        // When manually adjusting levels, we should update the phase information to keep guidance relevant
        if (procedurePhase === 'initial' || procedurePhase === 'descending') {
          // If decreasing by 10dB, user is following descending protocol
          if (change === -10) {
            setProcedurePhase('descending');
            setSuggestedAction('present');
            setCurrentGuidance(`You've decreased by 10 dB. Now present the tone to see if the patient can still hear it at ${newLevel} dB.`);
          } else if (change === 5 || change === 10) {
            // If increasing, provide guidance but keep the phase the same
            setSuggestedAction('present');
            setCurrentGuidance(`You've increased by ${change} dB. Present the tone to check for a response at ${newLevel} dB.`);
          } else if (change === -5) {
            // Non-standard adjustment
            setSuggestedAction('present');
            setCurrentGuidance(`You've decreased by 5 dB. While Hughson-Westlake protocol uses 10 dB decrements in the descending phase, you can still present the tone at ${newLevel} dB to check for a response.`);
          }
        } else if (procedurePhase === 'ascending') {
          // If increasing by 5dB, user is following ascending protocol
          if (change === 5) {
            setSuggestedAction('present');
            setCurrentGuidance(`You've increased by 5 dB. Now present the tone to see if the patient can hear it at ${newLevel} dB.`);
          } else if (change === 10) {
            setSuggestedAction('present');
            setCurrentGuidance(`You've increased by 10 dB. While Hughson-Westlake protocol uses 5 dB increments in the ascending phase, you can still present the tone at ${newLevel} dB to check for a response.`);
          } else if (change < 0) {
            // If decreasing during ascending phase, switch to descending phase
            setProcedurePhase('descending');
            setSuggestedAction('present');
            setCurrentGuidance(`You've decreased by ${Math.abs(change)} dB, changing to the descending phase. Present the tone to check for a response at ${newLevel} dB.`);
          }
        } else if (procedurePhase === 'threshold') {
          // IMPORTANT CHANGE: During threshold determination, don't reset counts when changing levels
          // Just continue using the same pattern (10dB down, 5dB up) while tracking responses at each level
          if (change === -10) {
            // User following standard protocol - decrease after a response
            setSuggestedAction('present');
            setCurrentGuidance(`You've decreased by 10 dB to ${newLevel} dB. This follows the Hughson-Westlake protocol. Present the tone to check for a response at this new level.`);
            console.log(`Threshold phase - decreased by 10dB to ${newLevel}dB`);
          } else if (change === 5) {
            // User following standard protocol - increase after no response
            setSuggestedAction('present');
            setCurrentGuidance(`You've increased by 5 dB to ${newLevel} dB. This follows the Hughson-Westlake protocol. Present the tone to check for a response at this new level.`);
            console.log(`Threshold phase - increased by 5dB to ${newLevel}dB`);
          } else {
            // Non-standard adjustment - just provide appropriate guidance
            setSuggestedAction('present');
            setCurrentGuidance(`You've changed the level to ${newLevel} dB. Present the tone to check for a response at this level.`);
            console.log(`Threshold phase - adjusted by ${change}dB to ${newLevel}dB (non-standard adjustment)`);
          }
          
          // Update UI to reflect the current level
          setLastResponseLevel(newLevel);
        } else if (procedurePhase === 'complete') {
          // Reset to threshold phase if changing level after completion
          setProcedurePhase('threshold');
          setSuggestedAction('present');
          setCurrentGuidance(`You're adjusting the level after completing threshold determination. You're now at ${newLevel} dB. Present the tone to check for a response.`);
        }
      }
      
      // Create a new object instead of mutating the existing one
      const updatedStep = {
        ...currentStep,
        currentLevel: newLevel
      };
      
      setCurrentStep(updatedStep);
      
      // Also update the session to keep everything in sync
      if (session) {
        // Create a new session object with new references
        const updatedSession = { ...session };
        
        // Create a new test sequence array with new references
        updatedSession.testSequence = [...updatedSession.testSequence];
        
        // Update the specific step in the sequence
        if (updatedSession.testSequence[updatedSession.currentStep]) {
          updatedSession.testSequence[updatedSession.currentStep] = {
            ...updatedSession.testSequence[updatedSession.currentStep],
            currentLevel: newLevel
          };
          
          setSession(updatedSession);
        }
      }
    } catch (error) {
      console.error("Error adjusting level:", error);
      setErrorMessage('Failed to adjust level. Please try again.');
    }
  }, [currentStep, session, trainerMode, procedurePhase]);

  // Handle skip step action - update for trainer mode
  const handleSkipStep = useCallback(() => {
    try {
      console.log('â­ï¸ handleSkipStep called - skipping to next frequency');
      
      // Reset trainer mode state for the new frequency
      if (trainerMode) {
        // We're changing the condition here to allow navigation even after storing a threshold
        // Previously this was preventing navigation after storing a threshold
        setProcedurePhase('initial');
        setLastResponseLevel(null);
        setSuggestedAction('present');
        setCurrentGuidance('Starting with a new frequency. Begin at a comfortable level.');
        console.log('Reset phase to: initial for new frequency in handleSkipStep');
      }
      
      // Use the updated skipCurrentStep method with false parameter to avoid marking as completed
      console.log('ðŸ“Š Before skip - Current session:', session?.currentStep);
      const nextStep = testingService.skipCurrentStep(false);
      console.log('ðŸ“Š After skip - Got next step:', nextStep?.frequency);
      
      // Force a refresh of the session directly
      const updatedSession = testingService.getCurrentSession();
      console.log('ðŸ“Š After skip - Updated session:', updatedSession?.currentStep);
      
      if (nextStep && updatedSession) {
        // Update both the session and current step states with forceful refresh
        console.log('ðŸ“Š Updating UI with new frequency:', nextStep.frequency);
        
        // Create fresh objects to ensure React detects the change
        // const freshSession = JSON.parse(JSON.stringify(updatedSession));
        // setSession(freshSession);
        
        const freshStep = JSON.parse(JSON.stringify(nextStep));
        setCurrentStep(freshStep);
        
        console.log('Moved to next frequency without marking complete:', nextStep.frequency);
        
        // Reset UI state for the new frequency
        if (trainerMode) {
          setProcedurePhase('initial');
          // IMPORTANT: Do NOT reset responseCounts here as it contains threshold information
          // Removed: setResponseCounts({});
        }
      } else {
        console.log('Test complete');
        const finalSession = testingService.completeSession();
        if (finalSession) {
          onComplete(finalSession);
        }
      }
    } catch (error) {
      console.error("Error skipping step:", error);
      setErrorMessage('Failed to skip to next step. Please try again.');
    }
  }, [onComplete, trainerMode, setErrorMessage, setSession, setCurrentStep, setProcedurePhase, setLastResponseLevel, setSuggestedAction, setCurrentGuidance, session]);

  // Add a new function to handle going to the previous frequency
  const handlePreviousStep = useCallback(() => {
    try {
      console.log('â®ï¸ handlePreviousStep called - going to previous frequency');
      
      // Reset trainer mode state for the previous frequency
      if (trainerMode) {
        setProcedurePhase('initial');
        setLastResponseLevel(null);
        setSuggestedAction('present');
        setCurrentGuidance('Returning to the previous frequency. Begin at a comfortable level.');
        console.log('Reset phase to: initial for previous frequency');
      }
      
      // We need to modify the session directly since TestingService may not have a specific 
      // method to go back to the previous step
      if (session) {
        console.log('ðŸ“Š Before navigating back - Current step:', session.currentStep);
        const updatedSession = JSON.parse(JSON.stringify(session));
        
        // Only go back if we're not already at the first step
        if (updatedSession.currentStep > 0) {
          updatedSession.currentStep -= 1;
          
          // Important: Get the previous step reference
          const previousStep = updatedSession.testSequence[updatedSession.currentStep];
          console.log('ðŸ“Š Going back to step:', updatedSession.currentStep, 'with frequency:', previousStep.frequency);
          
          // Update session and current step states with fresh objects
          setSession(updatedSession);
          
          const freshStep = JSON.parse(JSON.stringify(previousStep));
          setCurrentStep(freshStep);

          // CRITICAL FIX: Update the TestingService's internal state to match our navigation
          // This ensures that any audio played will use the correct frequency
          const currentSession = testingService.getCurrentSession();
          if (currentSession) {
            // Store the session in a variable first to avoid TypeScript null error
            currentSession.currentStep = updatedSession.currentStep;
            console.log(`ðŸ”„ Explicitly updated TestingService step to ${updatedSession.currentStep} with frequency ${previousStep.frequency}Hz`);
          }
          
          console.log('Moving to previous frequency:', previousStep.frequency);
        } else {
          console.log('Already at the first frequency, cannot go back further');
          setErrorMessage('Already at the first frequency.');
        }
      }
    } catch (error) {
      console.error("Error going to previous step:", error);
      setErrorMessage('Failed to go to previous step. Please try again.');
    }
  }, [session, trainerMode, setSession, setCurrentStep, setProcedurePhase, setLastResponseLevel, setSuggestedAction, setCurrentGuidance, setErrorMessage]);

  // Validate threshold according to Hughson-Westlake protocol
  const validateThreshold = useCallback((): { isValid: boolean; message: string } => {
    if (!currentStep) {
      return { isValid: false, message: 'No current test step available.' };
    }
    
    // Check responseCounts for any level with at least 2/3 positive responses
    let validLevel = null;
    let minValidLevel = Infinity;
    
    // First check our tracked response counts (more accurate)
    const frequencyData = responseCounts[currentStep.frequency];
    const earData = frequencyData?.[currentStep.ear] || {};
    
    Object.entries(earData).forEach(([levelStr, counts]) => {
      const level = parseInt(levelStr);
      // PROPER HUGHSON-WESTLAKE CRITERIA: at least 2 out of 3 responses at this level
      if (counts.total >= 3 && counts.heard >= 2 && level < minValidLevel) {
        validLevel = level;
        minValidLevel = level;
      }
    });
    
    if (validLevel !== null) {
      const counts = earData[validLevel];
      return { 
        isValid: true, 
        message: `Valid threshold at ${validLevel} dB - patient responded ${counts.heard}/${counts.total} times at this level.` 
      };
    }
    
    // If we didn't find a valid threshold in our tracked counts, check the responses array
    const { responses } = currentStep;
    
    // We need a minimum number of responses to establish a threshold
    if (responses.length < 3) {
      return { 
        isValid: false, 
        message: 'Not enough responses to determine a threshold. Hughson-Westlake requires at least 2 out of 3 responses at the same level.' 
      };
    }
    
    // Create a map of responses at each level
    const responsesAtLevels = new Map<number, { total: number, heard: number }>();
    
    responses.forEach(response => {
      const level = response.level;
      const existing = responsesAtLevels.get(level) || { total: 0, heard: 0 };
      existing.total += 1;
      if (response.response) {
        existing.heard += 1;
      }
      responsesAtLevels.set(level, existing);
    });
    
    // Check for any level with at least 2 out of 3 positive responses
    responsesAtLevels.forEach((counts, level) => {
      if (counts.total >= 3 && counts.heard >= 2 && level < minValidLevel) {
        validLevel = level;
        minValidLevel = level;
      }
    });
    
    if (validLevel !== null) {
      const counts = responsesAtLevels.get(validLevel) || { total: 0, heard: 0 };
      return { 
        isValid: true, 
        message: `Valid threshold at ${validLevel} dB - patient responded ${counts.heard}/${counts.total} times at this level.` 
      };
    } else {
      // Find the level with the most responses to give helpful feedback
      let maxResponses = 0;
      let mostTestedLevel = null;
      
      responsesAtLevels.forEach((counts, level) => {
        if (counts.total > maxResponses) {
          maxResponses = counts.total;
          mostTestedLevel = level;
        }
      });
      
      if (mostTestedLevel !== null) {
        const heardAtLevel = responsesAtLevels.get(mostTestedLevel)?.heard || 0;
        return { 
          isValid: false, 
          message: `Invalid threshold. At ${mostTestedLevel} dB, patient responded ${heardAtLevel}/${maxResponses} times, but Hughson-Westlake requires at least 2 out of 3 responses at the same level.` 
        };
      } else {
        return { 
          isValid: false, 
          message: 'Invalid threshold. Hughson-Westlake requires at least 2 out of 3 responses at the same level.' 
        };
      }
    }
  }, [currentStep, responseCounts]);
  
  // Helper function to determine if threshold can be stored
  const canStoreThreshold = useCallback(() => {
    return validateThreshold().isValid;
  }, [validateThreshold]);

  // Handle storing threshold and moving to next step
  const handleStoreThreshold = useCallback(() => {
    if (!currentStep) {
      console.error('Cannot store threshold: no current step');
      return;
    }
    
    // Validate the threshold first
    const validation = validateThreshold();
    if (!validation.isValid) {
      setErrorMessage(validation.message);
      return;
    }
    
    // Find the valid threshold level from our response counts
    let validThresholdLevel: number | null = null;
    let minValidLevel = Infinity;
    
    // Check the response counts for the current frequency and ear
    const frequencyData = responseCounts[currentStep.frequency];
    const earData = frequencyData?.[currentStep.ear] || {};
    
    Object.entries(earData).forEach(([levelStr, counts]) => {
      const level = parseInt(levelStr);
      if (counts.total >= 2 && counts.heard >= 2 && level < minValidLevel) {
        validThresholdLevel = level;
        minValidLevel = level;
      }
    });
    
    if (validThresholdLevel === null) {
      setErrorMessage('Could not determine a valid threshold level.');
      return;
    }
    
    console.log(`Storing threshold at validated level: ${validThresholdLevel}dB (current level is ${currentStep.currentLevel}dB)`);
    
    // Update the TestingService with the validated threshold level
    testingService.setCurrentLevel(validThresholdLevel as HearingLevel);
    
    // Mark the current step as completed without advancing to next step
    if (session) {
      const updatedSession = { ...session };
      const updatedStep = updatedSession.testSequence[updatedSession.currentStep];
      
      // Mark the step as completed and set responseStatus to 'threshold'
      updatedStep.completed = true;
      updatedStep.responseStatus = 'threshold';
      
      // Update our session state to reflect this change
      setSession(updatedSession);
      
      // Also update the currentStep to show it's completed with proper type validation
      if (currentStep) {
        const updatedCurrentStep: TestStep = {
          ...currentStep,
          completed: true,
          responseStatus: 'threshold'
        };
        
        setCurrentStep(updatedCurrentStep);
      }
      
      console.log(`Threshold stored at ${validThresholdLevel}dB, marked as completed but staying on current frequency`);
    }
    
    // Add clearer feedback for successful threshold storage and navigation instructions
    setCurrentGuidance(`Threshold successfully stored at ${validThresholdLevel} dB! You can now use the up arrow (or press Up) to move to the next frequency, or the down arrow to go to a previous frequency.`);
    
    // Update UI to indicate threshold recorded
    setProcedurePhase('complete');
    setSuggestedAction('next');
    
    // Update the response counts map with the stored threshold
    setResponseCounts(prev => {
      const newCounts = { ...prev };
      // At this point validThresholdLevel is guaranteed to be non-null since we checked above
      // Use type assertion to ensure TypeScript understands this
      const level = validThresholdLevel as HearingLevel;
      
      if (!newCounts[currentStep.frequency]) {
        newCounts[currentStep.frequency] = {};
      }
      
      if (!newCounts[currentStep.frequency][currentStep.ear]) {
        newCounts[currentStep.frequency][currentStep.ear] = {};
      }
      
      newCounts[currentStep.frequency][currentStep.ear][level] = {
        total: 3,  // Standard Hughson-Westlake criteria
        heard: 2   // At least 2 out of 3
      };
      
      return newCounts;
    });
  }, [currentStep, session, responseCounts, setErrorMessage, setSession, setCurrentStep, setCurrentGuidance, setProcedurePhase, setSuggestedAction, setResponseCounts]);

  // Initialize the test session - reset trainer mode
  useEffect(() => {
    try {
      // Reset trainer mode state
      setProcedurePhase('initial');
      setLastResponseLevel(null);
      setSuggestedAction('present');
      setCurrentGuidance('Start testing at a comfortable level (30-40 dB).');
      
      // Resume audio context on first user interaction
      audioService.resumeAudioContext().then(() => {
        const newSession = testingService.startSession(patient);
        setSession(newSession);
        setCurrentStep(testingService.getCurrentStep());
        
        // We don't want to reset responseCounts here as it will clear any stored thresholds
        // keeping the existing responseCounts which stores thresholds per frequency/ear
      });
    } catch (error) {
      console.error("Error initializing test session:", error);
      setErrorMessage('Failed to initialize test session. Please try again.');
    }
  }, [patient, setProcedurePhase, setLastResponseLevel, setSuggestedAction, setCurrentGuidance, setSession, setCurrentStep, setErrorMessage]);

  // Format frequency for display
  const formatFrequency = (freq: number): string => {
    return freq >= 1000 ? `${freq / 1000} kHz` : `${freq} Hz`;
  };

  // Start playing tone with beeping pattern
  const startTone = useCallback(() => {
    if (!currentStep) return;
    
    try {
      console.log('ðŸŽµ Starting tone...');
      
      // IMPORTANT: First, clear any existing intervals to prevent overlapping tones
      // This ensures we don't have multiple intervals running
      if (toneIntervalRef.current) {
        clearInterval(toneIntervalRef.current);
        toneIntervalRef.current = null;
        console.log('ðŸ§¹ Cleared existing tone interval');
      }
      
      // Also stop any currently playing tones to ensure a clean start
      audioService.stopTone();
      
      // Make sure TestingService has the correct level before playing
      if (currentStep) {
        // CRITICAL FIX: Ensure the testing service knows about our current step's frequency
        // This fixes the issue when navigating between frequencies
        const currentFrequency = currentStep.frequency;
        console.log(`ðŸ”Š Explicit frequency check: Using ${currentFrequency}Hz for tone`);
        
        // Ensure the testing service knows about our current manually set level
        testingService.setCurrentLevel(currentStep.currentLevel);
        console.log(`ðŸ”Š Starting tone at user-set level: ${currentStep.currentLevel}dB, phase: ${procedurePhase}`);
      }
      
      // Reset response states at the start of a new tone
      setPatientResponse(null);
      setPatientJustResponded(false);
      setShowResponseIndicator(false);
      console.log('ðŸ”„ Response states reset');
      
      // IMPORTANT: Set tone active state BEFORE playing tone 
      // This helps prevent race conditions in state updates
      setToneActive(true);
      console.log('ðŸ”Š Tone active set to true');
      
      // IMMEDIATELY play the initial tone - this happens right away when button is pressed
      testingService.playCurrentTone();
      console.log('ðŸŽµ Initial tone played');
      
      // IMMEDIATE response check - show response immediately if patient can hear it
      if (procedurePhase !== 'threshold') {
        const didRespond = simulatePatientResponse();
        console.log('ðŸ‘‚ Immediate patient response check:', didRespond);
        
        if (didRespond) {
          setPatientResponse(didRespond);
          setShowResponseIndicator(true);
          setPatientJustResponded(true);
          console.log('ðŸ‘‚ Patient IMMEDIATELY responded to the tone!');
        }
      }
      
      // For threshold phase - IMMEDIATELY record the presentation time
      // This ensures we accurately track when the student initiated the presentation
      if (procedurePhase === 'threshold') {
        console.log('ðŸŽ¯ In threshold phase - recording tone presentation time and DISABLING ALL automatic responses');
        lastPresentationTimeRef.current = Date.now();
        
        // In threshold phase, we DO NOT automatically determine the response
        // This will be handled only when the tone is stopped
        console.log('â³ Response will be determined when tone is stopped');
      } else {
        // For non-threshold phases, process automatic response after a brief delay
        console.log('â±ï¸ Setting up automatic response processing (non-threshold phase)');
        // Process only if not already responded
        setTimeout(() => {
          // Only process if tone is still active and no response yet
          if (toneActive && !patientResponse) {
            console.log('ðŸ“² Processing automatic response...');
            processAutomaticResponse();
          } else {
            console.log('âš ï¸ Tone no longer active or response already shown, skipping response processing');
          }
        }, 600);
      }
      
      // Set up beeping pattern (tone on for 800ms, off for 200ms)
      // This starts after the initial tone and creates a regular beeping pattern
      console.log('ðŸ”„ Setting up tone interval pattern');
      toneIntervalRef.current = setInterval(() => {
        // First check if we're still in active tone presentation
        if (!toneActive) {
          // Clean up interval if tone is no longer active
          console.log('âš ï¸ Tone no longer active in interval, cleaning up');
          if (toneIntervalRef.current) {
            clearInterval(toneIntervalRef.current);
            toneIntervalRef.current = null;
          }
          return;
        }
        
        // Use TestingService to play tone with specific duration
        if (currentStep) {
          console.log('ðŸ”„ Playing tone in interval pattern');
          // CRITICAL FIX: Ensure each interval tone also uses the explicit frequency
          const currentFrequency = currentStep.frequency;
          console.log(`ðŸ”„ Interval tone using frequency: ${currentFrequency}Hz`);
          testingService.playCurrentTone(800);
        }
      }, 1000); // Repeat every second
    } catch (error) {
      console.error("âŒ Error playing tone:", error);
      setErrorMessage('Failed to play tone. Please try again.');
      
      // Make sure to clean up if an error occurs
      if (toneIntervalRef.current) {
        clearInterval(toneIntervalRef.current);
        toneIntervalRef.current = null;
      }
      setToneActive(false);
      audioService.stopTone();
    }
  }, [currentStep, processAutomaticResponse, toneActive, procedurePhase, simulatePatientResponse, patientResponse]);

  // Update keyboard shortcuts to handle space bar press/release
  useEffect(() => {
    console.log('ðŸŽ® Setting up keyboard event handlers');
    
    // Keyboard event handler for key down
    const handleKeyDown = (e: KeyboardEvent) => {
      // Space bar - play tone
      if (e.code === 'Space' && !toneActive) {
        e.preventDefault();
        console.log('âŒ¨ï¸ Space key down - starting tone');
        startTone();
      }
      // Up arrow - increase level
      else if (e.code === 'ArrowUp' && e.shiftKey) {
        e.preventDefault();
        console.log('âŒ¨ï¸ Shift+Up arrow - increasing level by 5dB');
        handleAdjustLevel(5);
      }
      // Down arrow - decrease level
      else if (e.code === 'ArrowDown' && e.shiftKey) {
        e.preventDefault();
        console.log('âŒ¨ï¸ Shift+Down arrow - decreasing level by 5dB');
        handleAdjustLevel(-5);
      }
      // Up arrow - next frequency
      else if (e.code === 'ArrowUp' && !e.shiftKey) {
        e.preventDefault();
        console.log('âŒ¨ï¸ Up arrow - skipping to next frequency');
        handleSkipStep();
      }
      // Down arrow - previous frequency
      else if (e.code === 'ArrowDown' && !e.shiftKey) {
        e.preventDefault();
        console.log('âŒ¨ï¸ Down arrow - going to previous frequency');
        handlePreviousStep();
      }
      // S key - store threshold (when valid)
      else if (e.code === 'KeyS' && trainerMode && canStoreThreshold()) {
        e.preventDefault();
        console.log('âŒ¨ï¸ S key - storing threshold');
        handleStoreThreshold();
      }
    };

    // Keyboard event handler for key up
    const handleKeyUp = (e: KeyboardEvent) => {
      // Space bar release - stop tone
      if (e.code === 'Space' && toneActive) {
        e.preventDefault();
        console.log('âŒ¨ï¸ Space key up - stopping tone');
        stopTone();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      console.log('ðŸ§¹ Removing keyboard event handlers and cleaning up audio');
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      // Clean up audio when component unmounts
      audioService.stopTone();
    };
  }, [handleAdjustLevel, handleSkipStep, handlePreviousStep, handleStoreThreshold, startTone, stopTone, toneActive, trainerMode, responseCount, suggestedAction, canStoreThreshold, session]);

  // Update test progress when current step changes
  useEffect(() => {
    if (session && currentStep) {
      const totalSteps = session.testSequence.length;
      const currentStepIndex = session.currentStep;
      const progress = (currentStepIndex / totalSteps) * 100;
      setTestProgress(progress);
    }
  }, [session, currentStep]);

  // Memoize the thresholds calculation to prevent infinite re-renders
  const thresholds = useMemo((): ThresholdPoint[] => {
    if (!session) return [];
    
    return session.testSequence
      .map(step => {
        // Check if step is marked as completed AND has responseStatus 'threshold'
        // This ensures we only display dots for properly stored thresholds
        if (step.completed && step.responseStatus === 'threshold') {
          // For completed steps with stored thresholds, use the validated level
          console.log(`Including validated threshold for completed step: ${step.currentLevel}dB (frequency: ${step.frequency})`);
          
          return {
            frequency: step.frequency,
            hearingLevel: step.currentLevel,
            ear: step.ear,
            testType: step.testType,
            responseStatus: 'threshold'
          } as ThresholdPoint;
        } else {
          // Not a completed step with threshold - make sure it's shown as not tested
          return {
            frequency: step.frequency,
            hearingLevel: step.currentLevel,
            ear: step.ear,
            testType: step.testType,
            responseStatus: 'not_tested' 
          } as ThresholdPoint;
        }
      });
  }, [session]);

  // Handle implementing suggested action
  const handleSuggestedAction = useCallback(() => {
    if (!currentStep) return;
    
    console.log('Implementing suggested action:', suggestedAction);
    
    switch (suggestedAction) {
      case 'increase':
        // Implement increase by appropriate amount based on phase
        if (procedurePhase === 'ascending') {
          handleAdjustLevel(5); // 5 dB for ascending phase
          // Explicitly update phase after adjustment
          setProcedurePhase('ascending');
          console.log('Updated phase to: ascending after increasing by 5dB');
        } else {
          handleAdjustLevel(10); // 10 dB for initial phase
          if (procedurePhase === 'initial') {
            console.log('Remained in initial phase after increasing by 10dB');
          }
        }
        break;
      case 'decrease':
        handleAdjustLevel(-10); // 10 dB for descending phase
        // Explicitly update phase after adjustment
        setProcedurePhase('descending');
        console.log('Updated phase to: descending after decreasing by 10dB');
        break;
      case 'store_threshold':
        // Validate threshold before storing
        const { isValid, message } = validateThreshold();
        if (isValid) {
          handleStoreThreshold();
          setProcedurePhase('complete');
          console.log('Updated phase to: complete after storing threshold');
        } else {
          // Show error for invalid threshold
          setErrorMessage(message);
          setCurrentGuidance(message + ' Continue testing to establish a valid threshold.');
        }
        break;
      case 'next':
        handleSkipStep();
        // Reset to initial phase for the next frequency - don't reset responseCounts
        setProcedurePhase('initial');
        console.log('Reset phase to: initial for next frequency');
        break;
      case 'present':
        // No level adjustment needed, just guidance to present the tone
        setCurrentGuidance(`Present the tone at ${currentStep.currentLevel} dB to check for a response.`);
        // Don't change the phase when just presenting the tone
        break;
      default:
        console.log('Unknown suggested action:', suggestedAction);
    }
  }, [suggestedAction, procedurePhase, currentStep, handleAdjustLevel, handleStoreThreshold, handleSkipStep, validateThreshold, setCurrentGuidance, setErrorMessage, setProcedurePhase]);

  // Handle response recording - update for trainer mode
  const handleRecordResponse = useCallback((didRespond: boolean) => {
    if (!currentStep) return;
    
    try {
      // IMPORTANT CHANGE: When trainer mode is active, we want to manage our own state
      if (trainerMode) {
        // Record the response data
        const newResponse = {
          level: currentStep.currentLevel,
          response: didRespond
        };
        
        // Update current UI state based on response
        if (didRespond) {
          // If patient responded and we're in the ascending phase, this counts toward threshold
          if (procedurePhase === 'ascending') {
            // Update count of responses at this level
            const currentLevel = currentStep.currentLevel;
            const currentCount = responseCounts[currentLevel] || { total: 0, heard: 0 };
            
            // Create a new object to avoid mutating the state directly
            const updatedCounts = { ...responseCounts };
            updatedCounts[currentLevel] = {
              total: currentCount.total + 1,
              heard: currentCount.heard + 1
            };
            setResponseCounts(updatedCounts);
            
            // Check if we've reached the threshold criteria (2 out of 2, 3, or 4 responses)
            if (updatedCounts[currentLevel]?.heard >= 2) {
              // Threshold is established
              setProcedurePhase('complete');
              setSuggestedAction('store_threshold');
              setCurrentGuidance(`Threshold established at ${currentLevel} dB. The patient has responded ${updatedCounts[currentLevel]?.heard} times at this level during ascending trials. Per Hughson-Westlake procedure, this is the patient's threshold. Store this threshold and move to the next frequency.`);
              setLastResponseLevel(currentLevel);
            } else {
              // Continue ascending trials at this level
              setSuggestedAction('present');
              setCurrentGuidance(`The patient responded at ${currentLevel} dB. Per Hughson-Westlake procedure, continue presenting at this level to confirm the threshold. The patient needs to respond at least 2 times at the same level during ascending trials.`);
              setLastResponseLevel(currentLevel);
            }
          } else {
            // In initial or descending phase, decrease by 10dB after a response
            setProcedurePhase('descending');
            const newLevel = Math.max(-10, currentStep.currentLevel - 10) as HearingLevel;
            setSuggestedAction('decrease');
            setCurrentGuidance(`The patient responded at ${currentStep.currentLevel} dB. Following the Hughson-Westlake procedure, decrease the level by 10 dB to ${newLevel} dB and present the tone again.`);
            setLastResponseLevel(currentStep.currentLevel);
            
            // Update the step with the new level
            handleAdjustLevel(-10);
          }
        } else {
          // If no response, we're now in the ascending phase
          setProcedurePhase('ascending');
          const newLevel = Math.min(120, currentStep.currentLevel + 5) as HearingLevel;
          setSuggestedAction('increase');
          setCurrentGuidance(`No response at ${currentStep.currentLevel} dB. Following the Hughson-Westlake procedure, increase the level by 5 dB to ${newLevel} dB and present the tone again.`);
          setLastResponseLevel(currentStep.currentLevel);
          
          // Update the step with the new level
          handleAdjustLevel(5);
        }
        
        // IMPORTANT: Store the response in the step for record-keeping
        // without triggering the testing service's automatic level adjustment
        const updatedStep = {
          ...currentStep,
          responses: [...currentStep.responses, newResponse]
        };
        setCurrentStep(updatedStep);
        
        // Update session record
        if (session) {
          const updatedSession = { ...session };
          updatedSession.testSequence = [...updatedSession.testSequence];
          
          if (updatedSession.testSequence[updatedSession.currentStep]) {
            updatedSession.testSequence[updatedSession.currentStep] = {
              ...updatedSession.testSequence[updatedSession.currentStep],
              responses: [
                ...updatedSession.testSequence[updatedSession.currentStep].responses,
                newResponse
              ]
            };
            
            setSession(updatedSession);
          }
        }
      } else {
        // Standard mode - let the testing service handle the protocol
        const updatedStep = testingService.recordResponse(didRespond);
        if (updatedStep) {
          setCurrentStep({ ...updatedStep });
          
          // Check if we've moved to a new step
          const updatedSession = testingService.getCurrentSession();
          if (updatedSession) {
            setSession({ ...updatedSession });
          }
        }
      }
    } catch (error) {
      console.error("Error recording response:", error);
      setErrorMessage('Failed to record response. Please try again.');
    }
  }, [currentStep, session, trainerMode, procedurePhase, responseCounts, testingService, handleAdjustLevel]);

  if (!session || !currentStep) {
    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <Typography variant="h6">Initializing test session...</Typography>
        <LinearProgress sx={{ mt: 2 }} />
        {errorMessage && (
          <Alert severity="error" sx={{ mt: 2 }}>
            {errorMessage}
          </Alert>
        )}
      </Box>
    );
  }

  return (
    <Box sx={{ padding: 3 }}>
      <Grid container spacing={2}>
        {/* Header row */}
        <Grid item xs={12}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h5">
              Audiometry Testing - {currentStep?.ear === 'right' ? 'Right' : 'Left'} Ear
            </Typography>
            {session && session.patientId && (
              <FormControlLabel
                control={
                  <Switch
                    checked={trainerMode}
                    onChange={(e) => setTrainerMode(e.target.checked)}
                    color="primary"
                  />
                }
                label="Trainer Mode"
              />
            )}
          </Box>
          
          {/* Add testing status bar when trainer mode is active */}
          {trainerMode && (
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              justifyContent: 'space-between',
              mt: 1,
              p: 1,
              borderRadius: 1,
              bgcolor: '#f5f5f5',
              border: '1px solid #e0e0e0'
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Typography variant="subtitle2" sx={{ mr: 2, fontWeight: 'bold' }}>
                  Current Phase:
                </Typography>
                <Chip
                  label={(() => {
                    switch(procedurePhase) {
                      case 'initial': return 'Initial Presentation';
                      case 'descending': return 'Descending Phase (-10 dB)';
                      case 'ascending': return 'Ascending Phase (+5 dB)';
                      case 'threshold': return 'Threshold Determination';
                      case 'complete': return 'Threshold Complete';
                      default: return 'Initial Phase';
                    }
                  })()}
                  color={(() => {
                    switch(procedurePhase) {
                      case 'initial': return 'default';
                      case 'descending': return 'secondary';
                      case 'ascending': return 'primary';
                      case 'threshold': return 'warning';
                      case 'complete': return 'success';
                      default: return 'default';
                    }
                  })() as any}
                  size="small"
                />
              </Box>
              
              {responseCount > 0 && (
                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                  <Typography variant="subtitle2" sx={{ mr: 2, fontWeight: 'bold' }}>
                    Responses at {lastResponseLevel}dB:
                  </Typography>
                  <Box sx={{ display: 'flex', gap: 0.5 }}>
                    {[...Array(3)].map((_, i) => (
                      <Box
                        key={i}
                        sx={{
                          width: 24,
                          height: 24,
                          borderRadius: '50%',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          bgcolor: i < responseCount ? '#4caf50' : '#e0e0e0',
                          color: i < responseCount ? 'white' : 'black',
                          fontSize: 12,
                          fontWeight: 'bold'
                        }}
                      >
                        {i + 1}
                      </Box>
                    ))}
                  </Box>
                </Box>
              )}
              
              <Box>
                <Typography variant="subtitle2">
                  Test Progress: {Math.round(testProgress)}%
                </Typography>
              </Box>
            </Box>
          )}
        </Grid>

        {/* Main content row - Moved above the guidance panel */}
        <Grid item xs={12} md={6}>
          {/* Left column - Audiogram */}
          <Box sx={{ 
            height: 450, 
            display: 'flex', 
            flexDirection: 'column',
            mb: { xs: 2, md: 0 }
          }}>
            <Audiogram 
              thresholds={thresholds}
              currentFrequency={currentStep?.frequency}
              currentLevel={currentStep?.currentLevel}
              toneActive={Boolean(toneActive)}
            />
          </Box>
        </Grid>

        <Grid item xs={12} md={6}>
          {/* Right column - Patient and controls */}
          <Box sx={{ 
            height: 450, 
            display: 'flex', 
            flexDirection: 'column', 
            gap: 2,
            justifyContent: 'space-between'
          }}>
            {/* Patient image */}
            <Box sx={{ 
              flex: 1, 
              display: 'flex', 
              justifyContent: 'center', 
              alignItems: 'center', 
              position: 'relative',
              mb: 2,
              minHeight: 150
            }}>
              <PatientImage 
                patientId={session?.patientId} 
                responding={Boolean(patientResponse)}
                idle={!toneActive && !showResponseIndicator}
              />
              
              {/* Response notification */}
              {showResponseIndicator && (
                <Fade in={true}>
                  <Box
                    sx={{
                      position: 'absolute',
                      top: 0,
                      right: 0,
                      padding: 2,
                      borderRadius: 2,
                      backgroundColor: patientResponse ? 'rgba(76, 175, 80, 0.9)' : 'rgba(244, 67, 54, 0.9)',
                      color: 'white',
                      fontWeight: 'bold',
                      zIndex: 10,
                      boxShadow: 3,
                    }}
                  >
                    <Typography variant="subtitle1">
                      {patientResponse ? "Patient Response Detected!" : "No Response Detected"}
                    </Typography>
                  </Box>
                </Fade>
              )}
            </Box>

            {/* Controls section */}
            <Box sx={{ 
                p: 2, 
                borderRadius: 2, 
                border: '1px solid #e0e0e0',
                flexShrink: 0
              }}>
                {/* Frequency and level info */}
                <Box sx={{ mb: 3 }}>
                  <Box sx={{ 
                    display: 'flex', 
                    justifyContent: 'center', 
                    alignItems: 'center', 
                    gap: 3,
                    mb: 1 
                  }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Typography variant="h6" sx={{ mr: 1 }}>
                        Frequency: {formatFrequency(currentStep?.frequency || 0)}
                      </Typography>
                      <Box sx={{ display: 'flex', flexDirection: 'column' }}>
                        <IconButton 
                          size="small" 
                          color="primary" 
                          disabled={!currentStep || toneActive} 
                          onClick={handleSkipStep}
                          sx={{ p: 0.5 }}
                          aria-label="Next frequency"
                        >
                          <ArrowUpward />
                        </IconButton>
                        <IconButton 
                          size="small" 
                          color="secondary" 
                          disabled={!currentStep || toneActive || !session || session.currentStep === 0} 
                          onClick={handlePreviousStep}
                          sx={{ p: 0.5 }}
                          aria-label="Previous frequency"
                        >
                          <ArrowDownward />
                        </IconButton>
                      </Box>
                    </Box>
                  </Box>

                  <Box sx={{ 
                    display: 'flex', 
                    justifyContent: 'center', 
                    alignItems: 'center' 
                  }}>
                    <Typography variant="h6">
                      Level: {currentStep?.currentLevel || 0} dB HL
                    </Typography>
                  </Box>

                  <Box sx={{ 
                    display: 'flex', 
                    justifyContent: 'center', 
                    alignItems: 'center',
                    gap: 2,
                    mt: 1
                  }}>
                    <Tooltip title="Decrease by 10 dB (descending phase)">
                      <span>
                        <Button
                          size="small"
                          variant="outlined"
                          color="secondary"
                          disabled={!currentStep || toneActive}
                          onClick={() => handleAdjustLevel(-10)}
                          startIcon={<ArrowDownward />}
                        >
                          -10 dB
                        </Button>
                      </span>
                    </Tooltip>
                    <Tooltip title="Increase by 5 dB (ascending phase)">
                      <span>
                        <Button
                          size="small"
                          variant="outlined"
                          color="primary"
                          disabled={!currentStep || toneActive}
                          onClick={() => handleAdjustLevel(5)}
                          startIcon={<ArrowUpward />}
                        >
                          +5 dB
                        </Button>
                      </span>
                    </Tooltip>
                    <Tooltip title="Increase by 10 dB (initial phase)">
                      <span>
                        <Button
                          size="small"
                          variant="outlined"
                          color="primary"
                          disabled={!currentStep || toneActive}
                          onClick={() => handleAdjustLevel(10)}
                          startIcon={<ArrowUpward />}
                        >
                          +10 dB
                        </Button>
                      </span>
                    </Tooltip>
                  </Box>
                </Box>

                {/* Present tone button */}
                <Box sx={{ 
                  display: 'flex', 
                  justifyContent: 'center', 
                  alignItems: 'center',
                  mb: 2
                }}>
                  <Button
                    color="primary"
                    variant="contained"
                    size="large"
                    disabled={!currentStep}
                    onMouseDown={startTone}
                    onMouseUp={stopTone}
                    onMouseLeave={() => toneActive && stopTone()}
                    onTouchStart={startTone}
                    onTouchEnd={() => toneActive && stopTone()}
                    startIcon={<VolumeUp />}
                    fullWidth
                    sx={{ 
                      py: 1.5, 
                      borderRadius: 2,
                      backgroundColor: toneActive ? 'success.main' : 'primary.main',
                      '&:hover': {
                        backgroundColor: toneActive ? 'success.dark' : 'primary.dark',
                      }
                    }}
                  >
                    Present Tone
                  </Button>
                </Box>
                
                {/* Store threshold and skip buttons */}
                <Box sx={{ 
                  display: 'flex', 
                  justifyContent: 'space-between', 
                  alignItems: 'center',
                  gap: 2
                }}>
                  <Button
                    variant="outlined"
                    color="primary"
                    size="medium"
                    disabled={!currentStep || toneActive || !canStoreThreshold()}
                    onClick={handleStoreThreshold}
                    startIcon={<Check />}
                    fullWidth
                  >
                    Store Threshold
                  </Button>
                </Box>
              </Box>
            </Box>
          </Grid>
        </Grid>

        {/* Trainer guidance panel (when trainer mode is active) - Moved below the main content */}
        {trainerMode && (
          <Grid item xs={12}>
            <GuidancePanel
              guidance={currentGuidance}
              action={suggestedAction}
              phase={procedurePhase}
              onStoreThreshold={handleStoreThreshold}
              canStoreThreshold={canStoreThreshold()}
              patientResponded={patientJustResponded}
              onImplementSuggestion={handleSuggestedAction}
              showResponseAlert={showResponseIndicator && Boolean(patientResponse)}
            />
          </Grid>
        )}
      </Grid>

      {errorMessage && (
        <Snackbar open={!!errorMessage} autoHideDuration={6000} onClose={() => setErrorMessage('')}>
          <Alert onClose={() => setErrorMessage('')} severity="error">
            {errorMessage}
          </Alert>
        </Snackbar>
      )}
    </Box>
  );
};

export default TestingInterface;